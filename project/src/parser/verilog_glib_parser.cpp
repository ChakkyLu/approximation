// ./src/parser/verilog_glib_parser.cpp generated by reflex 1.0.9 from ./src/parser/verilog_glib_parser.l

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  OPTIONS USED                                                              //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#define vgl_REFLEX_OPTION_fast                true
#define vgl_REFLEX_OPTION_header_file         ./include/parser/verilog_glib_parser.h
#define vgl_REFLEX_OPTION_lex                 vgl_lex
#define vgl_REFLEX_OPTION_lexer               VGL_LEXER
#define vgl_REFLEX_OPTION_namespace           verilogglibparser
#define vgl_REFLEX_OPTION_outfile             ./src/parser/verilog_glib_parser.cpp
#define vgl_REFLEX_OPTION_prefix              vgl_

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %top{ user code %}                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 12 "./src/parser/verilog_glib_parser.l"

#include "circuit.h"
using namespace nodecircuit;
#include <string>


////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  REGEX MATCHER                                                             //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  ABSTRACT LEXER CLASS                                                      //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/abslexer.h>

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  LEXER CLASS                                                               //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace verilogglibparser {

class VGL_LEXER : public reflex::AbstractLexer<reflex::Matcher> {
#line 18 "./src/parser/verilog_glib_parser.l"

Node* current_node;
Node* temp_node;
int min_range;
int max_range;
int mode;
std::string name;
std::string dff_d;
std::string dff_q;
std::string dff_qn;
virtual int wrap() { return 1; }
public:
Circuit* circuit;

 public:
  typedef reflex::AbstractLexer<reflex::Matcher> AbstractBaseLexer;
  VGL_LEXER(
      const reflex::Input& input = reflex::Input(),
      std::ostream&        os    = std::cout)
    :
      AbstractBaseLexer(input, os)
  {
#line 33 "./src/parser/verilog_glib_parser.l"

circuit = NULL;
current_node = NULL;
min_range = max_range = 0;
mode = 255;
// 128:start 129:output 130:input 131:wire
// 140:gateinput 145:assign
// 150:dffreset 151:dffqn 152:dffq 153:dffd 154:dffclock
// 254:nothing 255:finish others:gate

  }
  static const int INITIAL = 0;
  virtual int vgl_lex();
  int vgl_lex(
      const reflex::Input& input,
      std::ostream        *os = NULL)
  {
    in(input);
    if (os)
      out(*os);
    return vgl_lex();
  }
};

} // namespace verilogglibparser

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 1: %{ user code %}                                                //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#line 1 "./src/parser/verilog_glib_parser.l"
// simple verilog structural gate library parser, without error recover, and without comment detection


#include <cstdio>
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>
using namespace std;



////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  SECTION 2: rules                                                          //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

namespace verilogglibparser {
extern void reflex_code_INITIAL(reflex::Matcher&);
} // namespace verilogglibparser

int verilogglibparser::VGL_LEXER::vgl_lex()
{
  static const reflex::Pattern PATTERN_INITIAL(reflex_code_INITIAL);
  if (!has_matcher())
  {
    matcher(new Matcher(PATTERN_INITIAL, stdinit(), this));
  }
  while (true)
  {
        switch (matcher().scan())
        {
          case 0:
            if (matcher().at_end())
            {
              return 0;
            }
            else
            {
              out().put(matcher().input());
            }
            break;
          case 1: // rule at line 71: (?:\Qendmodule\E)
#line 71 "./src/parser/verilog_glib_parser.l"
mode = 255;
            break;
          case 2: // rule at line 72: (?:\Qmodule\E)
#line 72 "./src/parser/verilog_glib_parser.l"
mode = 128;
            break;
          case 3: // rule at line 73: (?:\Qoutput\E)
#line 73 "./src/parser/verilog_glib_parser.l"
{mode = 129; min_range = 0; max_range = 0;}
            break;
          case 4: // rule at line 74: (?:\Qinput\E)
#line 74 "./src/parser/verilog_glib_parser.l"
{mode = 130; min_range = 0; max_range = 0;}
            break;
          case 5: // rule at line 75: (?:\Qwire\E)
#line 75 "./src/parser/verilog_glib_parser.l"
{mode = 131; min_range = 0; max_range = 0;}
            break;
          case 6: // rule at line 76: (?:\Qassign\E)
#line 76 "./src/parser/verilog_glib_parser.l"
mode = 145;
            break;
          case 7: // rule at line 77: (?:\QBUFF\E)(?:_[0-9A-Z_a-z]*)
#line 77 "./src/parser/verilog_glib_parser.l"
mode = NODE_BUF;
            break;
          case 8: // rule at line 78: (?:\QBUF\E)(?:_[0-9A-Z_a-z]*)
#line 78 "./src/parser/verilog_glib_parser.l"
mode = NODE_BUF;
            break;
          case 9: // rule at line 79: (?:\QINV\E)(?:_[0-9A-Z_a-z]*)
#line 79 "./src/parser/verilog_glib_parser.l"
mode = NODE_NOT;
            break;
          case 10: // rule at line 80: (?:\QNAND\E)(?:[2-9]_[0-9A-Z_a-z]*)
#line 80 "./src/parser/verilog_glib_parser.l"
mode = NODE_NAND;
            break;
          case 11: // rule at line 81: (?:\QAND\E)(?:[2-9]_[0-9A-Z_a-z]*)
#line 81 "./src/parser/verilog_glib_parser.l"
mode = NODE_AND;
            break;
          case 12: // rule at line 82: (?:\QXNOR2\E)(?:_[0-9A-Z_a-z]*)
#line 82 "./src/parser/verilog_glib_parser.l"
mode = NODE_XNOR;
            break;
          case 13: // rule at line 83: (?:\QXOR2\E)(?:_[0-9A-Z_a-z]*)
#line 83 "./src/parser/verilog_glib_parser.l"
mode = NODE_XOR;
            break;
          case 14: // rule at line 84: (?:\QNOR\E)(?:[2-9]_[0-9A-Z_a-z]*)
#line 84 "./src/parser/verilog_glib_parser.l"
mode = NODE_NOR;
            break;
          case 15: // rule at line 85: (?:\QOR\E)(?:[2-9]_[0-9A-Z_a-z]*)
#line 85 "./src/parser/verilog_glib_parser.l"
mode = NODE_OR;
            break;
          case 16: // rule at line 86: (?:\QDFFR\E)(?:_[0-9A-Z_a-z]*)
#line 86 "./src/parser/verilog_glib_parser.l"
mode = NODE_DFF;


            break;
          case 17: // rule at line 89: (?:\[[0-9][0-9]*:[0-9][0-9]*\])
#line 89 "./src/parser/verilog_glib_parser.l"
{ // mode is not changed!
          string range_str = text();
          int idx = 1;
          max_range = 0;
          while (range_str[idx] != ':') {
            max_range *= 10;
            max_range += range_str[idx]-'0';
            idx++;
          }
          idx++;
          min_range = 0;
          while (range_str[idx] != ']') {
            min_range *= 10;
            min_range += range_str[idx]-'0';
            idx++;
          }
          if (min_range > max_range) {
            int temp = min_range;
            min_range = max_range;
            max_range = temp;
          }
        }

            break;
          case 18: // rule at line 112: (?:[A-Za-z][0-9A-Z_a-z]*(?:\[[0-9][0-9]*\]))
#line 112 "./src/parser/verilog_glib_parser.l"
if (mode == 145) {
             current_node = circuit->GetNode(string(text()));
           }

            break;
          case 19: // rule at line 116: (?:[A-Za-z][0-9A-Z_a-z]*)
#line 116 "./src/parser/verilog_glib_parser.l"
switch (mode) {
        case 128:
          circuit->name = text();
          mode = 254;
          break;
        case 129:
          for (int i = min_range; i <= max_range; i++) {
            current_node = new Node;
            current_node->name = text();
            if (min_range != max_range)
              current_node->name += "["+std::to_string(i)+"]";
            current_node->is_output = true;
            circuit->outputs.push_back(current_node);
            circuit->all_nodes.push_back(current_node);
            circuit->all_nodes_map[current_node->name] = current_node;
          }
          break;
        case 130:
          for (int i = min_range; i <= max_range; i++) {
            current_node = new Node;
            current_node->name = text();
            if (min_range != max_range)
              current_node->name += "["+std::to_string(i)+"]";
            current_node->is_input = true;
            circuit->inputs.push_back(current_node);
            circuit->all_nodes.push_back(current_node);
            circuit->all_nodes_map[current_node->name] = current_node;
          }
          break;
        case 131:
          for (int i = min_range; i <= max_range; i++) {
            current_node = new Node;
            current_node->name = text();
            if (min_range != max_range)
              current_node->name += "["+std::to_string(i)+"]";
            circuit->all_nodes.push_back(current_node);
            circuit->all_nodes_map[current_node->name] = current_node;
          }
          break;
        case 145:
          current_node = circuit->GetNode(string(text()));
          break;
        case NODE_DFF:
          mode = 150;
          dff_d.clear();
          dff_q.clear();
          dff_qn.clear();
          break;
      }

            break;
          case 20: // rule at line 166: (?:(?:\Q.\E)(?:[A-Za-z][0-9A-Z_a-z]*)(?:\Q()\E))
#line 166 "./src/parser/verilog_glib_parser.l"
mode++;

            break;
          case 21: // rule at line 168: (?:(?:\Q.\E)(?:[A-Za-z][0-9A-Z_a-z]*))
#line 168 "./src/parser/verilog_glib_parser.l"
mode=mode;

            break;
          case 22: // rule at line 170: (?:(?:\Q(\E)(?:[A-Za-z][0-9A-Z_a-z]*(?:\[[0-9][0-9]*\]))(?:\Q)\E))
          case 23: // rule at line 171: (?:(?:\Q(\E)(?:[A-Za-z][0-9A-Z_a-z]*)(?:\Q)\E))
#line 171 "./src/parser/verilog_glib_parser.l"
switch (mode) {
          case NODE_BUF:
          case NODE_NOT:
          case NODE_AND:
          case NODE_NAND:
          case NODE_OR:
          case NODE_NOR:
          case NODE_XOR:
          case NODE_XNOR:
            name = text();
            name.erase(name.begin());
            name.erase(name.end()-1);
            current_node = circuit->GetNode(name);
            current_node->type = (NodeType)mode;
            mode = 140;
            break;
          case 140:
            name = text();
            name.erase(name.begin());
            name.erase(name.end()-1);
            temp_node = circuit->GetNode(name);
            current_node->inputs.push_back(temp_node);
            temp_node->outputs.push_back(current_node);
            break;
          case 150:
            mode = 151;
            break;
          case 151:
            name = text();
            name.erase(name.begin());
            name.erase(name.end()-1);
            dff_qn = name;
            mode = 152;
            break;
          case 152:
            name = text();
            name.erase(name.begin());
            name.erase(name.end()-1);
            dff_q = name;
            mode = 153;
            break;
          case 153:
            name = text();
            name.erase(name.begin());
            name.erase(name.end()-1);
            dff_d = name;
            mode = 154;
            break;
          case 154:
            if (dff_q.size() == 0) {
              dff_q = dff_qn+"_not";
              current_node = new Node;
              current_node->name = dff_q;
              circuit->all_nodes.push_back(current_node);
              circuit->all_nodes_map[current_node->name] = current_node;
            }
            else {
              current_node = circuit->GetNode(dff_q);
            }
            current_node->type = NODE_DFF;
            circuit->ffs.push_back(current_node);
            temp_node = circuit->GetNode(dff_d);
            current_node->inputs.push_back(temp_node);
            temp_node->outputs.push_back(current_node);
            if (dff_qn.size() > 0) {
              temp_node = circuit->GetNode(dff_qn);
              temp_node->type = NODE_NOT;
              current_node->outputs.push_back(temp_node);
              temp_node->inputs.push_back(current_node);
            }
            mode = 254;
            break;
        }

            break;
          case 24: // rule at line 245: (?:1'b0)
#line 245 "./src/parser/verilog_glib_parser.l"
if (mode == 145) {
         current_node->type = NODE_ZERO;
       }

            break;
          case 25: // rule at line 249: (?:1'b1)
#line 249 "./src/parser/verilog_glib_parser.l"
if (mode == 145) {
          current_node->type = NODE_ONE;
       }

            break;
          case 26: // rule at line 253: (?:(?:\Q(\E)(?:1'b0)(?:\Q)\E))
#line 253 "./src/parser/verilog_glib_parser.l"
if (mode == 140) {
             temp_node = circuit->GetNode("zero_zero");
             if (!temp_node) {
               temp_node = new Node(NODE_ZERO);
               temp_node->name = "zero_zero";
               circuit->all_nodes.push_back(temp_node);
               circuit->all_nodes_map[temp_node->name] = temp_node;
             }
             current_node->inputs.push_back(temp_node);
             temp_node->outputs.push_back(current_node);
           }

            break;
          case 27: // rule at line 265: (?:(?:\Q(\E)(?:1'b1)(?:\Q)\E))
#line 265 "./src/parser/verilog_glib_parser.l"
if (mode == 140) {
             temp_node = circuit->GetNode("one_one");
             if (!temp_node) {
               temp_node = new Node(NODE_ONE);
               temp_node->name = "one_one";
               circuit->all_nodes.push_back(temp_node);
               circuit->all_nodes_map[temp_node->name] = temp_node;
             }
             current_node->inputs.push_back(temp_node);
             temp_node->outputs.push_back(current_node);
           }

            break;
          case 28: // rule at line 277: .
#line 277 "./src/parser/verilog_glib_parser.l"
mode=mode;

            break;
        }
  }
}

////////////////////////////////////////////////////////////////////////////////
//                                                                            //
//  TABLES                                                                    //
//                                                                            //
////////////////////////////////////////////////////////////////////////////////

#include <reflex/matcher.h>

namespace verilogglibparser {

void reflex_code_INITIAL(reflex::Matcher& m)
{
  int c0 = 0, c1 = c0;
  m.FSM_INIT(c1);

S0:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'w') goto S54;
  if (c1 == 'o') goto S38;
  if (c1 == 'm') goto S30;
  if (c1 == 'i') goto S46;
  if (c1 == 'e') goto S22;
  if ('b' <= c1 && c1 <= 'z') goto S131;
  if (c1 == 'a') goto S62;
  if (c1 == '[') goto S128;
  if (c1 == 'X') goto S103;
  if (c1 == 'O') goto S112;
  if (c1 == 'N') goto S86;
  if (c1 == 'I') goto S78;
  if (c1 == 'D') goto S120;
  if ('C' <= c1 && c1 <= 'Z') goto S131;
  if (c1 == 'B') goto S70;
  if (c1 == 'A') goto S95;
  if (c1 == '1') goto S147;
  if (c1 == '.') goto S138;
  if (c1 == '(') goto S142;
  if ('\v' <= c1) goto S150;
  if ('\n' <= c1) return m.FSM_HALT(c1);
  if ('\0' <= c1 && c1 <= '\t') goto S150;
  return m.FSM_HALT(c1);

S22:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S152;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S30:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S169;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S38:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S177;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S46:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S185;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S54:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S193;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S62:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 's') goto S201;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S70:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'U') goto S209;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S78:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'N') goto S217;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S86:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'O') goto S233;
  if ('B' <= c1 && c1 <= 'Z') goto S162;
  if (c1 == 'A') goto S225;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S95:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'N') goto S241;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S103:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'O') goto S257;
  if (c1 == 'N') goto S249;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S112:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'R') goto S265;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S120:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'F') goto S273;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S128:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S281;
  return m.FSM_HALT(c1);

S131:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S138:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S284;
  if ('A' <= c1 && c1 <= 'Z') goto S284;
  return m.FSM_HALT(c1);

S142:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S291;
  if ('A' <= c1 && c1 <= 'Z') goto S291;
  if (c1 == '1') goto S298;
  return m.FSM_HALT(c1);

S147:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\'') goto S300;
  return m.FSM_HALT(c1);

S150:
  m.FSM_TAKE(28);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S152:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S302;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S160:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S310;
  return m.FSM_HALT(c1);

S162:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S169:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S313;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S177:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S321;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S185:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S329;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S193:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'r') goto S337;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S201:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 's') goto S345;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S209:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'F') goto S353;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S217:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'V') goto S361;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S225:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'N') goto S368;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S233:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'R') goto S376;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S241:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'D') goto S384;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S249:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'O') goto S392;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S257:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'R') goto S400;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S265:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('2' <= c1 && c1 <= '9') goto S408;
  if ('0' <= c1 && c1 <= '1') goto S162;
  return m.FSM_HALT(c1);

S273:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'F') goto S415;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S281:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ':') goto S423;
  if ('0' <= c1 && c1 <= '9') goto S281;
  return m.FSM_HALT(c1);

S284:
  m.FSM_TAKE(21);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S284;
  if (c1 == '_') goto S284;
  if ('A' <= c1 && c1 <= 'Z') goto S284;
  if ('0' <= c1 && c1 <= '9') goto S284;
  if (c1 == '(') goto S425;
  return m.FSM_HALT(c1);

S291:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S291;
  if (c1 == '_') goto S291;
  if (c1 == '[') goto S427;
  if ('A' <= c1 && c1 <= 'Z') goto S291;
  if ('0' <= c1 && c1 <= '9') goto S291;
  if (c1 == ')') goto S429;
  return m.FSM_HALT(c1);

S298:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '\'') goto S431;
  return m.FSM_HALT(c1);

S300:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S433;
  return m.FSM_HALT(c1);

S302:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'm') goto S436;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S310:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S444;
  if ('0' <= c1 && c1 <= '9') goto S310;
  return m.FSM_HALT(c1);

S313:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S446;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S321:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'p') goto S454;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S329:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S462;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S337:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S470;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S345:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'i') goto S477;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S353:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S492;
  if (c1 == '[') goto S160;
  if (c1 == 'F') goto S485;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S361:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S499;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S368:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'D') goto S506;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S376:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('2' <= c1 && c1 <= '9') goto S514;
  if ('0' <= c1 && c1 <= '1') goto S162;
  return m.FSM_HALT(c1);

S384:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('2' <= c1 && c1 <= '9') goto S521;
  if ('0' <= c1 && c1 <= '1') goto S162;
  return m.FSM_HALT(c1);

S392:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'R') goto S528;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S400:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if (c1 == '2') goto S536;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S408:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S543;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S415:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if (c1 == 'R') goto S550;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S423:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S557;
  return m.FSM_HALT(c1);

S425:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ')') goto S560;
  return m.FSM_HALT(c1);

S427:
  c0 = c1, c1 = m.FSM_CHAR();
  if ('0' <= c1 && c1 <= '9') goto S562;
  return m.FSM_HALT(c1);

S429:
  m.FSM_TAKE(23);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S431:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'b') goto S565;
  return m.FSM_HALT(c1);

S433:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '1') goto S570;
  if (c1 == '0') goto S568;
  return m.FSM_HALT(c1);

S436:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'o') goto S572;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S444:
  m.FSM_TAKE(18);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S446:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S580;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S454:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S588;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S462:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S596;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S470:
  m.FSM_TAKE(5);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S477:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'g') goto S603;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S485:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S611;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S492:
  m.FSM_TAKE(8);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S492;
  if (c1 == '_') goto S492;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S492;
  if ('0' <= c1 && c1 <= '9') goto S492;
  return m.FSM_HALT(c1);

S499:
  m.FSM_TAKE(9);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S499;
  if (c1 == '_') goto S499;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S499;
  if ('0' <= c1 && c1 <= '9') goto S499;
  return m.FSM_HALT(c1);

S506:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('2' <= c1 && c1 <= '9') goto S618;
  if ('0' <= c1 && c1 <= '1') goto S162;
  return m.FSM_HALT(c1);

S514:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S625;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S521:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S632;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S528:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if (c1 == '2') goto S639;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S536:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S646;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S543:
  m.FSM_TAKE(15);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S543;
  if (c1 == '_') goto S543;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S543;
  if ('0' <= c1 && c1 <= '9') goto S543;
  return m.FSM_HALT(c1);

S550:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S653;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S557:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S660;
  if ('0' <= c1 && c1 <= '9') goto S557;
  return m.FSM_HALT(c1);

S560:
  m.FSM_TAKE(20);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S562:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ']') goto S662;
  if ('0' <= c1 && c1 <= '9') goto S562;
  return m.FSM_HALT(c1);

S565:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == '1') goto S666;
  if (c1 == '0') goto S664;
  return m.FSM_HALT(c1);

S568:
  m.FSM_TAKE(24);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S570:
  m.FSM_TAKE(25);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S572:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'd') goto S668;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S580:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S676;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S588:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 't') goto S683;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S596:
  m.FSM_TAKE(4);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S603:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'n') goto S690;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S611:
  m.FSM_TAKE(7);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S611;
  if (c1 == '_') goto S611;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S611;
  if ('0' <= c1 && c1 <= '9') goto S611;
  return m.FSM_HALT(c1);

S618:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S697;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S625:
  m.FSM_TAKE(14);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S625;
  if (c1 == '_') goto S625;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S625;
  if ('0' <= c1 && c1 <= '9') goto S625;
  return m.FSM_HALT(c1);

S632:
  m.FSM_TAKE(11);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S632;
  if (c1 == '_') goto S632;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S632;
  if ('0' <= c1 && c1 <= '9') goto S632;
  return m.FSM_HALT(c1);

S639:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S704;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S646:
  m.FSM_TAKE(13);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S646;
  if (c1 == '_') goto S646;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S646;
  if ('0' <= c1 && c1 <= '9') goto S646;
  return m.FSM_HALT(c1);

S653:
  m.FSM_TAKE(16);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S653;
  if (c1 == '_') goto S653;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S653;
  if ('0' <= c1 && c1 <= '9') goto S653;
  return m.FSM_HALT(c1);

S660:
  m.FSM_TAKE(17);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S662:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ')') goto S711;
  return m.FSM_HALT(c1);

S664:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ')') goto S713;
  return m.FSM_HALT(c1);

S666:
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == ')') goto S715;
  return m.FSM_HALT(c1);

S668:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'u') goto S717;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S676:
  m.FSM_TAKE(2);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S683:
  m.FSM_TAKE(3);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S690:
  m.FSM_TAKE(6);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S697:
  m.FSM_TAKE(10);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S697;
  if (c1 == '_') goto S697;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S697;
  if ('0' <= c1 && c1 <= '9') goto S697;
  return m.FSM_HALT(c1);

S704:
  m.FSM_TAKE(12);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S704;
  if (c1 == '_') goto S704;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S704;
  if ('0' <= c1 && c1 <= '9') goto S704;
  return m.FSM_HALT(c1);

S711:
  m.FSM_TAKE(22);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S713:
  m.FSM_TAKE(26);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S715:
  m.FSM_TAKE(27);
  c0 = c1, c1 = m.FSM_CHAR();
  return m.FSM_HALT(c1);

S717:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'l') goto S725;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S725:
  m.FSM_TAKE(19);
  c0 = c1, c1 = m.FSM_CHAR();
  if (c1 == 'e') goto S733;
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);

S733:
  m.FSM_TAKE(1);
  c0 = c1, c1 = m.FSM_CHAR();
  if ('a' <= c1 && c1 <= 'z') goto S162;
  if (c1 == '_') goto S162;
  if (c1 == '[') goto S160;
  if ('A' <= c1 && c1 <= 'Z') goto S162;
  if ('0' <= c1 && c1 <= '9') goto S162;
  return m.FSM_HALT(c1);
}

} // namespace verilogglibparser
